# BookStore-Remarks

### 1.关于MemoryRiver

其实可以理解为`std::vector<T>`，且可以直接进行文件读写，之所以要实现这个东西是因为在每个测试包具有连续性，就是说里面的测试点其实属于同一个事件，按照顺序依次发生，这就需要通过文件的读写来记录上一段交互发生了什么，然后下一个测试点接着继续做。在实际的项目设计时这种可持久化是必要的。当然在BookStore的设计中不存在拷贝留存历史版本的需要，可以把它当一个支持从末端添数据并根据索引读写的数据结构。

### 2.关于块状链表与FileStore：

块状链表的本质是利用分块的思想平衡数组和链表的复杂度。

数组支持O(1)查询/修改，但插入和删除是O(n)的，因为每插入一个都要把后面所有的往后移，腾出一个位置。

链表支持O(1)插入/删除（只要改前后节点的前驱/后继），但是访问是O(n)的，因为要从头开始一个个往后跳。

如果要维护的数据结构既要支持访问又要支持增删，这两种东西就都不太合适，所以块状链表应运而生。

块状链表就是把这两种数据结构结合在一起，把数组挂在链表的节点上，或者说链表的每个节点是一个数组。

假设数据规模是N，块状链表有A个节点，每个节点是一个长度为B的数组，那么访问某个数据的过程是先从链表表头跳到那个数据所在数组对应的节点，然后在数组中直接访问，复杂度是O(A)的。插入某个数据是先找到插入数据位置对应的节点，然后暴力修改这个节点对应的数组，复杂度是O(A+B)的，现在希望这两件事情的复杂度尽可能相等，于是A和B都应该取在$\sqrt N$ 的级别，这也就是块状链表的块长。

为了确保每个块的块长始终都在这个级别，每次插入数据后都要检查这个块是不是太长了，超出设定的块长时就要把这个块裂解成两块，在链表中新建一个节点，把原本块中的后一部分数据移动到新的节点中。

同样，如果某个删除操作把一个块删空了，那么就要把这个块对应的节点删掉。

BookStore的存储是要用块状链表实现一个对文件的 `std::map`，就是要支持对文件的映射，也就是根据关键词`key`可以对应的`item`

考虑一种已经定义了比较运算的数据类型`T`，以之作为键值，那么在存数据的时候就按照键值的大小关系顺序在块状链表里。简而言之就是一个分块数组，维护一下每块的“最大值”，每个元素插进去的时候就看是不是比当前块的最大值大，如果是的话说明肯定不在这个块里，直接跳到下一个块，如果是的话说明就应该插在这个块里，然后在块里暴力修改。查询也是一样的。应为块长和块的数量都是$\sqrt N$，所以复杂度就是$O(q\sqrt N)$的，可以通过。

然后写成模板类就可以了，对链表和数组分别开一个`MemeoryRiver` 类储存每个节点/数组块的的ID。（就相当于把块状链表每个点的下标从原本的`a[...]`改成用`MemoryRiver`存）

### 3.一种可行的设计思路：

FileStore的实现方法如上。

然后整个书店可以归结为两个系统：账户系统和图书系统。

账户系统用一个栈维护用户信息，每登录一个用户就把用户信息进栈，登出就出栈，然后现存的所有用户可以用一个FileStore类来维护。

图书系统也用一个FileStore类，用来维护已经有的图书信息（图书不会被删除），重点在与要维护一个和用户栈匹配的图书栈表示当前用户选择的图书。也就是说，对账户状态的操作和对图书状态的操作应该是同步的。

为了方便解析指令，可能需要手写一个字符串类，这在小作业中有所涉及。

财务系统可以单独实现，也可以直接在图书系统里一并实现。

比如以下的结构：

```
root
├── src
│   ├── BookSys.hpp #图书系统
│   ├── AccountSys.hpp #账户系统
│   ├── Book.hpp #图书类
│   ├── Account.hpp #账户类
│   ├── Chars.hpp #字符串类
│   └── Command.hpp #指令解析器
│   └── FileStore.hpp #文件存储类
└── include
    └── main.cpp
```



### 3. 实现细节：

- 指令解析：以空格为标识截取指令词，注意头尾空格和连续空格的处理。
- 尽量把所有东西都封装起来，注意`friend class`的关系。
- 图书类、账户类：充分定义运算符，注意必要的初始化。因为这要放进FileStore，而FileStore依赖于键值的储存。
- 索引图书：要求通过多种方式索引图书，所以对每种索引方式都要单独存储，注意文件数不要超限。（如果每个FileStore要分别对链表和数组建一个文件记录ID，最多就只能开10个FileStore）
- 关于`keyword`部分，方便起见可以用一个`std::map`来判断关键词是否会重复，在目前的测试下，这并不会影响程序的性能。
- 关于`delete`操作中判定这个账户是否登录的问题，直接暴力扫描整个登陆栈的复杂度是错误的，但是可以通过测试。
- 多写一些`check`函数来检查**指令语法正确性**、**用户状态**、**图书状态**，这对简化代码有好处，因为检查是很频繁的。
- 务必仔细阅读标准要求中关于指令格式的要求，确保每一条都判掉了，尤其是**特殊说明**。

### 4.Conner Case：

- 指令中有任何不可见字符都是不合法的，可以用`isprint()`来判断。

- 尽管注册的账号的权限至少都是1，但是管理员可以手动创建权限为0的账号并登录，所以所有操作都要检查权限。

- `Author,BookName,keyword`等的长度限制不包括双引号。

- 虽然空格符属于可见ASCII字符，但在测试数据中它不出现在任何指令单词中，包括`"..."`中的内容。（这也是通过空格解析指令可行的原因）

- 实数中`.10,10.`等输入都是不合法的。

- 实数的读入不保证是小数点两位，小数位数超过两位是非法的。

- 读入数字的地方可能会读入奇怪的东西，当然这是非法的。

- 所有数字讯息中出现前导0都是非法的。

  

